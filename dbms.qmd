---
title: "DBMS"
pagetitle: "DBMS"
description: "Database tidbits & SQL snippets"
image: "/static/database.jpg"
---

# PostgreSQL

## pg_dump 

[Reference](https://www.postgresql.org/docs/12/app-pgdump.html)

`pg_dump -h [host] -d [database] -U [user] -s [schema only] -W [force password] > <file>.sql`

## Primary Key Relationships

**Columns**

- table_schema: PK schema name
- table_name: PK table name
- constraint_name: PK constraint name
- position: index of column in table (1, 2, ...). 2 or higher means key is composite (contains more than one column)
- key_column: PK column name

**Rows**

- One row represents one primary key column
- Scope of rows: columns of all PK constraints in a database
- Ordered by table schema, table name, column position


```{sql}
select * from (
	-- Main query. Returns all tables
	select kcu.table_schema,
		   kcu.table_name,
		   tco.constraint_name,
		   kcu.ordinal_position as position,
		   kcu.column_name as key_column
	from information_schema.table_constraints tco
	join information_schema.key_column_usage kcu 
		 on kcu.constraint_name = tco.constraint_name
		 and kcu.constraint_schema = tco.constraint_schema
		 and kcu.constraint_name = tco.constraint_name
	where tco.constraint_type = 'PRIMARY KEY'
	order by kcu.table_schema,
			 kcu.table_name,
			 position
) main
where table_name = 'd_location'
```

## Foreign Key Relationships

**Columns**

- foreign_table: foreign table schema and name
- rel: relationship symbol implicating direction
- primary_table: primary (rerefenced) table schema and name
- fk_columns: list of FK colum names, separated with ","
- constraint_name: foreign key constraint name

**Rows**

- One row represents one foreign key.
- If foreign key consists of multiple columns (composite key) it is still represented as one row.
- Scope of rows: all foregin keys in a database.
- Ordered by foreign table schema name and table name.

## Ordering Tables by FK

```{sql}
drop table if exists dependencies cascade;
create temporary table dependencies as
select 
        tc.table_name as child,
        tu.table_name as parent
from 
        information_schema.table_constraints as tc
        inner join information_schema.constraint_table_usage as tu
             on tu.constraint_name = tc.constraint_name
where 
        tc.constraint_type = 'FOREIGN KEY'
        and tc.table_name <> tu.table_name;

with recursive dep_depth as (
 select
  dep.child,
  dep.parent,
  1 as lvl
 from
  dependencies as dep
 union all
 select
  dep.child,
  dep.parent,
  dd.lvl + 1 as lvl
 from
  dep_depth as dd
  inner join dependencies as dep on dep.parent = dd.child
 )
select
 table_name,
 table_order
from (
 select
  dd.parent as table_name,
  max(lvl) as table_order
 from
  dep_depth as dd
 group by
  table_name
 union
 select
  dd.child as table_name,
  max(lvl) + 1 as level
 from
  dep_depth as dd
  left join dependencies as dp on dp.parent = dd.child
 where
  dp.parent is null
 group by
  dd.child
 ) as all_levels
 order by table_order;
```


```{sql}
select * from (
	-- Main query. Returns FK relationships for all tables
	select 
			kcu.table_schema as table_schema,
			kcu.table_name as foreign_table,
		   '>-' as relationship,
		   rel_tco.table_name as primary_table,
		   string_agg(kcu.column_name, ', ') as fk_columns,
		   kcu.constraint_name
	from information_schema.table_constraints tco
	join information_schema.key_column_usage kcu
			  on tco.constraint_schema = kcu.constraint_schema
			  and tco.constraint_name = kcu.constraint_name
	join information_schema.referential_constraints rco
			  on tco.constraint_schema = rco.constraint_schema
			  and tco.constraint_name = rco.constraint_name
	join information_schema.table_constraints rel_tco
			  on rco.unique_constraint_schema = rel_tco.constraint_schema
			  and rco.unique_constraint_name = rel_tco.constraint_name
	where tco.constraint_type = 'FOREIGN KEY'
	group by kcu.table_schema,
			 kcu.table_name,
			 rel_tco.table_name,
			 rel_tco.table_schema,
			 kcu.constraint_name
	order by kcu.table_schema,
			 kcu.table_name
) main
where primary_table = 'd_location'
```

## Create DB

```{sql}
create database <new_db_name> owner <user_or_group> template <name_of_db_to_use_as_template>;
-- show search_path;
set search_path to <default_schema>,public;
create extension if not exists postgis;
create extension if not exists dblink;


-- Database Creation
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
create database <new_db_name> owner <user_or_group> template <name_of_db_to_use_as_template>;
-- show search_path;
set search_path to idb, public;

grant connect, temporary on database <new_db_name> to public;
grant all on database <new_db_name> to <user>;
grant all on database <new_db_name> to <group>;

create extension if not exists postgis;
create extension if not exists dblink;

create schema staging;

-- Add a unique constraint to e_analyte.full_name and e_analyte.cas_rn so that
--	no full name or cas_rn can be used for more than one analyte
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alter table e_analyte
  add constraint uc_fullname unique(full_name),
  add constraint uc_casrn unique(cas_rn);
```


## DBLink

```{sql}
select
  a.*, b.*
from
  table1 as a
  left join (
    select * from dblink(
      'dbname=<database>',
      'select col1, col2, col3 from <table>'
    ) as d (
      col1 text, col2 text, col3 text
    )
  ) as b
  on a.col1 = b.col2
```

## Partitioning

```{sql, eval=F, inclute=T, class.source='fold-show'}
select * from (
    select *, row_number() over(
        partition by
            col1, col2, col3
        order by col1 desc
    ) rowid
    from sometable
) someid
where rowid > 1;
```

## Temporary Objects

```{sql, eval=F, inclute=T, class.source='fold-show'}
SELECT
	n.nspname as SchemaName,
	c.relname as RelationName,
	CASE c.relkind
		WHEN 'r' THEN 'table'
		WHEN 'v' THEN 'view'
		WHEN 'i' THEN 'index'
		WHEN 'S' THEN 'sequence'
		WHEN 's' THEN 'special'
		END as RelationType,
	pg_catalog.pg_get_userbyid(c.relowner) as RelationOwner,             
	pg_size_pretty(pg_relation_size(n.nspname ||'.'|| c.relname)) as RelationSize
FROM pg_catalog.pg_class c
LEFT JOIN pg_catalog.pg_namespace AS n ON n.oid = c.relnamespace
	WHERE  c.relkind IN ('r','s') 
	AND  (n.nspname !~ '^pg_toast' and nspname like 'pg_temp%')
ORDER BY pg_relation_size(n.nspname ||'.'|| c.relname) DESC;
```


## Table Relationships

[https://dataedo.com/kb/query/postgresql/list-tables-with-most-relationships](https://dataedo.com/kb/query/postgresql/list-tables-with-most-relationships)

```{sql}
select * from
(select relations.table_name as table_name, -- schema name and table name
       count(relations.table_name) as relationships, -- number of table relationships
       count(relations.referenced_tables) as foreign_keys, -- number of foreign keys in a table
       count(relations.referencing_tables) as references, -- number of foreign keys that are refering to this table
       count(distinct related_table) as related_tables, -- number of related tables
       count(distinct relations.referenced_tables) as referenced_tables, -- number of different tables referenced with FKs (multiple FKs can refer to one table, so number of FKs might be different than number of referenced tables)
       count(distinct relations.referencing_tables) as referencing_tables -- number of different tables that are refering to this table (similar to referenced_tables)
from(
     select pk_tco.table_schema || '.' || pk_tco.table_name as table_name,
            fk_tco.table_schema || '.' || fk_tco.table_name as related_table,
            fk_tco.table_name as referencing_tables,
            null::varchar(100) as referenced_tables
     from information_schema.referential_constraints rco
     join information_schema.table_constraints fk_tco
          on rco.constraint_name = fk_tco.constraint_name
          and rco.constraint_schema = fk_tco.table_schema
     join information_schema.table_constraints pk_tco
          on rco.unique_constraint_name = pk_tco.constraint_name
          and rco.unique_constraint_schema = pk_tco.table_schema
    union all
    select fk_tco.table_schema || '.' || fk_tco.table_name as table_name,
           pk_tco.table_schema || '.' || pk_tco.table_name as related_table,
           null as referencing_tables,
           pk_tco.table_name as referenced_tables
    from information_schema.referential_constraints rco
    join information_schema.table_constraints fk_tco 
         on rco.constraint_name = fk_tco.constraint_name
         and rco.constraint_schema = fk_tco.table_schema
    join information_schema.table_constraints pk_tco
         on rco.unique_constraint_name = pk_tco.constraint_name
         and rco.unique_constraint_schema = pk_tco.table_schema
) relations
group by table_name
order by relationships asc) results

where substring(table_name, 5, 2) = 'd_'; -- substring(string, start_position, length)
```

## Current Database

```{sql}
select * from pg_catalog.current_database()
```

## Current user/role

```{sql}
select * from current_role
select * from current_user
```

## Process ID

```{sql}
select * from pg_catalog.pg_backend_pid()
```

## List functions/defs/args

```{sql}
select 
	pg_get_userbyid(p.proowner) as owner,
	n.nspname as function_schema,
	p.proname as function_name,
	l.lanname as function_language,
	case when l.lanname = 'internal' then p.prosrc
		else pg_get_functiondef(p.oid)
		end as definition,
	pg_get_function_arguments(p.oid) as function_arguments,
	t.typname as return_type
from pg_proc p
	left join pg_namespace n on p.pronamespace = n.oid
	left join pg_language l on p.prolang = l.oid
	left join pg_type t on t.oid = p.prorettype 
where n.nspname not in ('pg_catalog', 'information_schema')
and n.nspname = 'idb'
order by function_schema, function_name;
```

## Whos logged in

```{sql}
select * from pg_stat_activity
where usename != '' and usename != 'postgres'
order by usename, pid
```

## Aggregate Functions

[https://www.postgresql.org/docs/9.6/catalog-pg-aggregate.html](https://www.postgresql.org/docs/9.6/catalog-pg-aggregate.html)

```{sql}
-- pg_proc contains data for aggregate functions as well as plain functions
select * from pg_proc
-- pg_aggregate is an extension of pg_proc.
select * from pg_aggregate
```

## List users

```{sql}
SELECT rolname FROM pg_roles;
```

## List tables in database

```{sql}
SELECT table_schema,table_name FROM information_schema.tables ORDER BY table_schema,table_name;
```

## List columns in table

```{sql}
SELECT column_name
FROM   information_schema.columns
WHERE  table_schema = 'schema'
AND    table_name = 'table';
```

## Update From

```{sql}
UPDATE tablename
SET columnname = someothervalue
FROM ...
WHERE ...
```

## Materialized View

[Reference](https://www.postgresqltutorial.com/postgresql-materialized-views/)

```{sql}
CREATE MATERIALIZED VIEW view_name
AS
query
WITH [NO] DATA;
```

When you refresh data for a materialized view, PostgreSQL locks the entire table therefore you cannot query data against it. To avoid this, you can use the CONCURRENTLY option.

With CONCURRENTLY option, PostgreSQL creates a temporary updated version of the materialized view, compares two versions, and performs INSERT and UPDATE only the differences.

```{sql}
REFRESH MATERIALIZED VIEW CONCURRENTLY view_name;
```

## Constants

```{sql}
WITH myconstants (analyte_search) as (
   values ('%Hexachlorocyclopentadiene%')
)

SELECT *
FROM e_analyte, myconstants
WHERE analyte ilike analyte_search
   OR full_name ilike analyte_search
   OR aliases ilike analyte_search;
```

## Sequential Keys

```{sql}
seq_key bigint NOT NULL DEFAULT nextval('seq_key'::regclass)

ALTER SEQUENCE seq_key RESTART WITH 3;
```

## Cross-Database Search

This could be refined further by creating a function.

```{sql}
with
dbrows as (
	select * from dblink(
		'dbname=chemcrit',
		'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
		) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
		'dbname=ahtna',
		'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
		) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=arkema_ph',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=bae_north',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=bayer_ldw',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=bcsa',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=c840_livent',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=cabotroad',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=centralia',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=centredale',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=eos',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=evraz_inwater',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=frenchtown_mill',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=gemt_columbus',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=gemt_meridian',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=gemt_springfield',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=reddog',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=shoreham',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=solvay',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
  union
	select * from dblink(
	'dbname=three_m_mb',
	'select analyte, full_name, chem_class, aliases, cas_rn from e_analyte'
	) as d (analyte text, full_name text, chem_class text, aliases text, cas_rn text)
),
const (param) as (
	values ('%solid%')
)
select analyte, full_name, chem_class, cas_rn, aliases
from dbrows, const
where analyte ilike param
or full_name ilike param
or aliases ilike param
order by chem_class, analyte;
```
