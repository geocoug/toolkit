{
  "hash": "1d7e40019e057b2dd5100be294288db9",
  "result": {
    "markdown": "---\ntitle: Python\ndescription: Python programming language\nimage: https://img.icons8.com/?size=512&id=13441&format=png\n---\n\n## Batch File Rename\n\n```py\nimport glob\nimport os\n\nfor filename in glob.glob(\"./**/*.ext\", recursive=True):\n    new_name = \"-\".join(filename.split(\"_\"))\n    os.rename(filename, new_name)\n```\n\n## Logging Basics\n\n```py\nimport argparse\nimport logging\nimport os\nfrom datetime import datetime\n\n# Do not specify __name__ to use root log level\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nformatter = logging.Formatter(\n    \"%(asctime)s : %(msecs)04d : %(name)s : %(levelname)s : %(message)s\",\n    datefmt=\"%Y-%m-%d %H:%M:%S\",\n)\nlog_file = (\n    f\"{os.path.splitext(__file__)[0]}_{datetime.now().strftime('%Y-%m-%d_%H%M%S')}.log\"\n)\nstream_handler = logging.StreamHandler()\nstream_handler.setFormatter(formatter)\n\n\ndef clparser() -> argparse.ArgumentParser:\n    \"\"\"Create a parser to handle input arguments and displaying a help message.\"\"\"\n    desc_msg = \"\"\"My logging program.\"\"\"\n    parser = argparse.ArgumentParser(description=desc_msg)\n    parser.add_argument(\n        \"-l\",\n        \"--logfile\",\n        action=\"store_true\",\n        help=\"Write log messages to a file.\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"Control the amount of information to display.\",\n    )\n    return parser\n\n\nif __name__ == \"__main__\":\n    args = clparser().parse_args()\n    if args.verbose:\n        logger.addHandler(stream_handler)\n    if args.logfile:\n        file_handler = logging.FileHandler(filename=log_file)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n    logger.info(\"Begin my test module\")\n```\n\n## Sending HTTP Requests\n\n```py\nimport logging\n\nimport requests\n\nlogger = logging.getLogger(__name__)\n\n\ndef send_request(request_type: str, url: str, **kwargs) -> requests.Response:\n    \"\"\"Send an HTTP request.\n\n    Args:\n    ----\n        request_type (str): Accepts \"GET\" or \"POST\"\n        url (str): Request URL\n\n    Returns:\n    -------\n        requests.Response: Request response.\n    \"\"\"\n    valid_methods = (\"GET\", \"POST\")\n    if request_type.upper() not in valid_methods:\n        raise ValueError(f\"Invalid request type. Supported types: {valid_methods}\")\n    try:\n        response = requests.request(request_type.upper(), url, **kwargs)\n        response.raise_for_status()  # Raises an exception if status code >= 400\n        return response\n    except requests.exceptions.RequestException as err:\n        logger.error(f\"{err}. Request type: {request_type}. URL: {url}. Args: {kwargs}\")\n        raise err\n\n# Example GET request\nresponse = send_request(\"GET\", \"https://api.publicapis.org/entries\", timeout=5)\nlogger.info(response.json())\n\n# Example POST request\nresponse = send_request(\"POST\", \"https://someurl.com\", headers={}, timeout=5)\nlogger.info(response.json())\n```\n\n## Regular Expressions\n\n- [Quickstart](https://www.rexegg.com/regex-quickstart.html)\n- [Regex101](https://regex101.com/)\n\n### MetaCharacters (Need to be escaped)\n\n`. ^ $ * + ? { } [ ] \\ | ( )`\n\n### Characters\n\n`.`       - Any Character Except New Line<br>\n`\\d`      - Digit (0-9)<br>\n`\\D`      - Not a Digit (0-9)<br>\n`\\w`      - Word Character (a-z, A-Z, 0-9, _)<br>\n`\\W`      - Not a Word Character<br>\n`\\s`      - Whitespace (space, tab, newline)<br>\n`\\S`      - Not Whitespace (space, tab, newline)<br>\n\n### Character Classes\n\n`[]`      - Matches Characters in brackets<br>\n`[^ ]`    - Matches Characters NOT in brackets<br>\n`[a-z]`   - Any lowercase character between a and z<br>\n`[A-Z]`   - Any UPPERCASE character between A and Z<br>\n\n### Quantifiers\n\n`*`       - 0 or More<br>\n`+`       - 1 or More<br>\n`?`       - 0 or One<br>\n`{3}`     - Exact Number<br>\n`{3,4}`   - Range of Numbers (Minimum, Maximum)<br>\n`{3,}`    - At least 3<br>\n\n### Anchors & Boundaries\n\n`\\b`      - Word Boundary<br>\n`\\B`      - Not a Word Boundary<br>\n`^`       - Beginning of a String<br>\n`$`       - End of a String<br>\n\n### Logic\n\n`|`       - Either Or<br>\n`( )`     - Group<br>\n`\\1`      - Contents of group 1<br>\n\n### White-space\n\n`\\t`      - Tab<br>\n`\\r`      - Carriage return<br>\n`\\n`      - New line<br>\n\n### Example\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport re\n\ntext_string = \"\"\"\nHello world\n\n8001234567\n800-321-7654\n900.987.6543\n\nsome.email@email.com\nmycompany@company.net\nwierd-12-address-4@somedomain.blah\n\"\"\"\n\npattern = re.compile(r\"[0-9]{3}[.-]?[0-9]{3}[.-]?[0-9]{4}\")\nmatches = re.finditer(pattern, text_string)\n\nfor match in matches:\n    print(match)\n    print(match.span())\n    print(text_string[match.start() : match.end()])\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<re.Match object; span=(14, 24), match='8001234567'>\n(14, 24)\n8001234567\n<re.Match object; span=(25, 37), match='800-321-7654'>\n(25, 37)\n800-321-7654\n<re.Match object; span=(38, 50), match='900.987.6543'>\n(38, 50)\n900.987.6543\n```\n:::\n:::\n\n\n## OOP Basics\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nclass Employee:\n    \"\"\"Create an employee object with relevant attributes.\"\"\"\n\n    annual_raise_pct = 0.04\n    employee_no = 1\n\n    def __init__(self, first_name, last_name, position, years_employed=1):\n        \"\"\"Function called when new object is initiated.\"\"\"\n        self.first_name = first_name\n        self.last_name = last_name\n        self.position = position\n        self.years_employed = years_employed\n        self.employee_number = Employee.employee_no\n        self.email = self.first_name + \".\" + self.last_name + \"@company.com\"\n        self.salary = self.calculate_salary()\n        Employee.employee_no += 1\n\n    def starting_salary(self):\n        \"\"\"Return the starting salary for each position at company\"\"\"\n        if self.position == \"HR\":\n            return 25000\n        elif self.position == \"Management\":\n            return 50000\n        elif self.position == \"Developer\":\n            return 100000\n        elif self.position == \"CEO\":\n            return 200000\n        else:\n            return None\n\n    def calculate_salary(self):\n        salary = self.starting_salary()\n        for year in range(self.years_employed):\n            salary = int(salary + (salary * Employee.annual_raise_pct))\n        return salary\n\n    def __repr__(self):\n        \"\"\"Create representational object string\"\"\"\n        return f\"\"\"Employee(first_name = {self.first_name}, last_name = {self.last_name}, position = {self.position}, years_employed = {self.years_employed})\"\"\"\n\n\ncurrent_employees = [\n    Employee(\"Geo\", \"Coug\", \"Developer\", 6),\n    Employee(\"Jane\", \"Doe\", \"HR\", 4),\n    Employee(\"John\", \"Doe\", \"Management\", 15),\n    Employee(\"Bob\", \"Loblaw\", \"CEO\", 24),\n]\n\nfor e in current_employees:\n    print(f\"Employee Number: {e.employee_number}\")\n    print(e)\n    print(\"Email:\", e.email)\n    print(\"Salary: ${:,}\\n\".format(e.salary))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEmployee Number: 1\nEmployee(first_name = Geo, last_name = Coug, position = Developer, years_employed = 6)\nEmail: Geo.Coug@company.com\nSalary: $126,530\n\nEmployee Number: 2\nEmployee(first_name = Jane, last_name = Doe, position = HR, years_employed = 4)\nEmail: Jane.Doe@company.com\nSalary: $29,245\n\nEmployee Number: 3\nEmployee(first_name = John, last_name = Doe, position = Management, years_employed = 15)\nEmail: John.Doe@company.com\nSalary: $90,039\n\nEmployee Number: 4\nEmployee(first_name = Bob, last_name = Loblaw, position = CEO, years_employed = 24)\nEmail: Bob.Loblaw@company.com\nSalary: $512,645\n\n```\n:::\n:::\n\n\n## DBMS Data Types\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf = pd.read_csv(\"../../../static/development/data-types.csv\")\ndf.to_html(index=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n<table border=\"1\" class=\"dataframe\">\\n  <thead>\\n    <tr style=\"text-align: right;\">\\n      <th>Data Type</th>\\n      <th>Postgres</th>\\n      <th>MariaDB</th>\\n      <th>SQL Server</th>\\n      <th>Firebird</th>\\n      <th>MS-Access</th>\\n      <th>SQLite</th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr>\\n      <td>Timestamp with time zone</td>\\n      <td>1184.0</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Timestamp</td>\\n      <td>1184.0</td>\\n      <td>7</td>\\n      <td>NaN</td>\\n      <td>type ‘datetime.datetime’</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Datetime</td>\\n      <td>NaN</td>\\n      <td>12</td>\\n      <td>class ‘datetime.datetime’</td>\\n      <td>NaN</td>\\n      <td>class ‘datetime.datetime’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Date</td>\\n      <td>1082.0</td>\\n      <td>10</td>\\n      <td>class ‘datetime.date’</td>\\n      <td>type ‘datetime.date’</td>\\n      <td>class ‘datetime.datetime’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Time</td>\\n      <td>1083.0</td>\\n      <td>11</td>\\n      <td>class ‘datetime.time’</td>\\n      <td>type ‘datetime.time’</td>\\n      <td>class ‘datetime.datetime’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Boolean</td>\\n      <td>16.0</td>\\n      <td>16</td>\\n      <td>class ‘bool’</td>\\n      <td>NaN</td>\\n      <td>class ‘bool’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Small integer</td>\\n      <td>21.0</td>\\n      <td>1</td>\\n      <td>class ‘int’</td>\\n      <td>NaN</td>\\n      <td>class ‘int’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Integer</td>\\n      <td>23.0</td>\\n      <td>2</td>\\n      <td>class ‘int’</td>\\n      <td>type ‘int’</td>\\n      <td>class ‘int’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Long integer</td>\\n      <td>20.0</td>\\n      <td>3</td>\\n      <td>class ‘int’</td>\\n      <td>type ‘long’</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Single</td>\\n      <td>701.0</td>\\n      <td>4</td>\\n      <td>class ‘float’</td>\\n      <td>type ‘float’</td>\\n      <td>class ‘float’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Double precision</td>\\n      <td>701.0</td>\\n      <td>5</td>\\n      <td>class ‘float’</td>\\n      <td>type ‘float’</td>\\n      <td>class ‘float’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Decimal</td>\\n      <td>1700.0</td>\\n      <td>0</td>\\n      <td>class ‘decimal.Decimal’</td>\\n      <td>class ‘decimal.Decimal’</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Currency</td>\\n      <td>790.0</td>\\n      <td>NaN</td>\\n      <td>NaN</td>\\n      <td>class ‘decimal.Decimal’</td>\\n      <td>class ‘decimal.Decimal’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Character</td>\\n      <td>1042.0</td>\\n      <td>NaN</td>\\n      <td>class ‘str’</td>\\n      <td>type ‘str’</td>\\n      <td>class ‘str’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Character varying</td>\\n      <td>1043.0</td>\\n      <td>15</td>\\n      <td>class ‘str’</td>\\n      <td>type ‘str’</td>\\n      <td>class ‘str’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Text</td>\\n      <td>25.0</td>\\n      <td>NaN</td>\\n      <td>class ‘str’</td>\\n      <td>type ‘str’</td>\\n      <td>class ‘str’</td>\\n      <td>NaN</td>\\n    </tr>\\n    <tr>\\n      <td>Binary / BLOB</td>\\n      <td>17.0</td>\\n      <td>249,250,251,252</td>\\n      <td>class ‘bytearray’</td>\\n      <td>type ‘str’</td>\\n      <td>type ‘bytearray’</td>\\n      <td>NaN</td>\\n    </tr>\\n  </tbody>\\n</table>\n:::\n:::\n\n\n## DBMS Libraries\n\n- Postgres: `psycopg2`\n- MariaDB: `pymysql`\n- SQL Server: `pyodbc`\n- Firebird: `fdb`\n- MS-Access: `pyodbc`\n- SQLite: `sqlite3`\n\n## DB Table Dependencies\n\n```py\ndef dependency_order(dep_list):\n    rem_tables = list(set([t[0] for t in dep_list] + [t[1] for t in dep_list]))\n    rem_dep = copy.copy(dep_list)\n    sortkey = 1\n    ret_list = []\n    while len(rem_dep) > 0:\n        tbls = [tbl for tbl in rem_tables if tbl not in [dep[0] for dep in rem_dep]]\n        ret_list.extend([(tb, sortkey) for tb in tbls])\n        rem_tables = [tbl for tbl in rem_tables if tbl not in tbls]\n        rem_dep = [dep for dep in rem_dep if dep[1] not in tbls]\n        sortkey += 1\n    if len(rem_tables) > 0:\n        ret_list.extend([(tb, sortkey) for tb in rem_tables])\n    ret_list.sort(cmp=lambda x, y: cmp(x[1], y[1]))\n    return [item[0] for item in ret_list]\n```\n\n## CSV Sniffer\n\n```py\nimport re\n\nclass CsvDiagError(Exception):\n    def __init__(self, msg):\n        self.value = msg\n\n    def __str__(self):\n        return self.value\n\nclass CsvLine:\n    escchar = \"\\\\\"\n\n    def __init__(self, line_text):\n        self.text = line_text\n        self.delim_counts = {}\n        self.item_errors = []  # A list of error messages.\n\n    def __str__(self):\n        return \"; \".join(\n            [\n                \"Text: <<%s>>\" % self.text,\n                \"Delimiter counts: <<%s>>\"\n                % \", \".join(\n                    [\n                        \"%s: %d\" % (k, self.delim_counts[k])\n                        for k in self.delim_counts.keys()\n                    ]\n                ),\n            ]\n        )\n\n    def count_delim(self, delim):\n        # If the delimiter is a space, consider multiple spaces to be equivalent\n        # to a single delimiter, split on the space(s), and consider the delimiter\n        # count to be one fewer than the items returned.\n        if delim == \" \":\n            self.delim_counts[delim] = max(0, len(re.split(r\" +\", self.text)) - 1)\n        else:\n            self.delim_counts[delim] = self.text.count(delim)\n\n    def delim_count(self, delim):\n        return self.delim_counts[delim]\n\n    def _well_quoted(self, element, qchar):\n        # A well-quoted element has either no quotes, a quote on each end and none\n        # in the middle, or quotes on both ends and every internal quote is either\n        # doubled or escaped.\n        # Returns a tuple of three booleans; the first indicates whether the element is\n        # well-quoted, the second indicates whether the quote character is used\n        # at all, and the third indicates whether the escape character is used.\n        if qchar not in element:\n            return (True, False, False)\n        if len(element) == 0:\n            return (True, False, False)\n        if element[0] == qchar and element[-1] == qchar and qchar not in element[1:-1]:\n            return (True, True, False)\n        # The element has quotes; if it doesn't have one on each end, it is not well-quoted.\n        if not (element[0] == qchar and element[-1] == qchar):\n            return (False, True, False)\n        e = element[1:-1]\n        # If there are no quotes left after removing doubled quotes, this is well-quoted.\n        if qchar not in e.replace(qchar + qchar, \"\"):\n            return (True, True, False)\n        # if there are no quotes left after removing escaped quotes, this is well-quoted.\n        if qchar not in e.replace(self.escchar + qchar, \"\"):\n            return (True, True, True)\n        return (False, True, False)\n\n    def record_format_error(self, pos_no, errmsg):\n        self.item_errors.append(\"%s in position %d.\" % (errmsg, pos_no))\n\n    def items(self, delim, qchar):\n        # Parses the line into a list of items, breaking it at delimiters that are not\n        # within quoted stretches.  (This is a almost CSV parser, for valid delim and qchar,\n        # except that it does not eliminate quote characters or reduce escaped quotes.)\n        self.item_errors = []\n        if qchar is None:\n            if delim is None:\n                return self.text\n            else:\n                if delim == \" \":\n                    return re.split(r\" +\", self.text)\n                else:\n                    return self.text.split(delim)\n        elements = []  # The list of items on the line that will be returned.\n        eat_multiple_delims = delim == \" \"\n        # States of the FSM:\n        # _IN_QUOTED: An opening quote has been seen, but no closing quote encountered.\n        #  Actions / transition:\n        #   quote: save char in escape buffer / _ESCAPED\n        #   esc_char : save char in escape buffer / _ESCAPED\n        #   delimiter: save char in element buffer / _IN_QUOTED\n        #   other: save char in element buffer / _IN_QUOTED\n        # _ESCAPED: An escape character has been seen while _IN_QUOTED (and is in the escape buffer).\n        #  Actions / transitions\n        #   quote: save escape buffer in element buffer, empty escape buffer,\n        #    save char in element buffer / _IN_QUOTED\n        #   delimiter: save escape buffer in element buffer, empty escape buffer,\n        #    save element buffer, empty element buffer / _BETWEEN\n        #   other: save escape buffer in element buffer, empty escape buffer,\n        #    save char in element buffer / _IN_QUOTED\n        # _QUOTE_IN_QUOTED: A quote has been seen while _IN_QUOTED (and is in the escape buffer).\n        #  Actions / transitions\n        #   quote: save escape buffer in element buffer, empty escape buffer,\n        #    save char in element buffer / _IN_QUOTED\n        #   delimiter: save escape buffer in element buffer, empty escape buffer,\n        #    save element buffer, empty element buffer / _DELIMITED\n        #   other: save escape buffer in element buffer, empty escape buffer,\n        #    save char in element buffer / _IN_QUOTED\n        #     (An 'other' character in this position represents a bad format:\n        #     a quote not followed by another quote or a delimiter.)\n        # _IN_UNQUOTED: A non-delimiter, non-quote has been seen.\n        #  Actions / transitions\n        #   quote: save char in element buffer / _IN_UNQUOTED\n        #    (This represents a bad format.)\n        #   delimiter: save element buffer, empty element buffer / _DELIMITED\n        #   other: save char in element buffer / _IN_UNQUOTED\n        # _BETWEEN: Not in an element, and a delimiter not seen.  This is the starting state,\n        #   and the state following a closing quote but before a delimiter is seen.\n        #  Actions / transition:\n        #   quote: save char in element buffer / _IN_QUOTED\n        #   delimiter: save element buffer, empty element buffer / _DELIMITED\n        #    (The element buffer should be empty, representing a null data item.)\n        #   other: save char in element buffer / _IN_UNQUOTED\n        # _DELIMITED: A delimiter has been seen while not in a quoted item.\n        #  Actions / transition:\n        #   quote: save char in element buffer / _IN_QUOTED\n        #   delimiter: if eat_multiple: no action / _DELIMITED\n        #     if not eat_multiple: save element buffer, empty element buffer / _DELIMITED\n        #   other: save char in element buffer / _IN_UNQUOTED\n        # At end of line: save escape buffer in element buffer, save element buffer.  For a well-formed\n        # line, these should be empty, but they may not be.\n        #\n        # Define the state constants, which will also be used as indexes into an execution vector.\n        (\n            _IN_QUOTED,\n            _ESCAPED,\n            _QUOTE_IN_QUOTED,\n            _IN_UNQUOTED,\n            _BETWEEN,\n            _DELIMITED,\n        ) = range(6)\n        #\n        # Because of Python 2.7's scoping rules:\n        # * The escape buffer and current element are defined as mutable objects that will have their\n        #  first elements modified, rather than as string variables.  (Python 2.x does not allow\n        #  modification of a variable in an enclosing scope that is not the global scope, but\n        #  mutable objects like lists can be altered.  Another approach would be to implement this\n        #  as a class and use instance variables.)\n        # * The action functions return the next state rather than assigning it directly to the 'state' variable.\n        esc_buf = [\"\"]\n        current_element = [\"\"]\n\n        def in_quoted():\n            if c == self.escchar:\n                esc_buf[0] = c\n                return _ESCAPED\n            elif c == qchar:\n                esc_buf[0] = c\n                return _QUOTE_IN_QUOTED\n            else:\n                current_element[0] += c\n                return _IN_QUOTED\n\n        def escaped():\n            if c == delim:\n                current_element[0] += esc_buf[0]\n                esc_buf[0] = \"\"\n                elements.append(current_element[0])\n                current_element[0] = \"\"\n                return _BETWEEN\n            else:\n                current_element[0] += esc_buf[0]\n                esc_buf[0] = \"\"\n                current_element[0] += c\n                return _IN_QUOTED\n\n        def quote_in_quoted():\n            if c == qchar:\n                current_element[0] += esc_buf[0]\n                esc_buf[0] = \"\"\n                current_element[0] += c\n                return _IN_QUOTED\n            elif c == delim:\n                current_element[0] += esc_buf[0]\n                esc_buf[0] = \"\"\n                elements.append(current_element[0])\n                current_element[0] = \"\"\n                return _DELIMITED\n            else:\n                current_element[0] += esc_buf[0]\n                esc_buf[0] = \"\"\n                current_element[0] += c\n                self.record_format_error(\n                    i + 1, \"Unexpected character following a closing quote\"\n                )\n                return _IN_QUOTED\n\n        def in_unquoted():\n            if c == delim:\n                elements.append(current_element[0])\n                current_element[0] = \"\"\n                return _DELIMITED\n            else:\n                current_element[0] += c\n                return _IN_UNQUOTED\n\n        def between():\n            if c == qchar:\n                current_element[0] += c\n                return _IN_QUOTED\n            elif c == delim:\n                elements.append(current_element[0])\n                current_element[0] = \"\"\n                return _DELIMITED\n            else:\n                current_element[0] += c\n                return _IN_UNQUOTED\n\n        def delimited():\n            if c == qchar:\n                current_element[0] += c\n                return _IN_QUOTED\n            elif c == delim:\n                if not eat_multiple_delims:\n                    elements.append(current_element[0])\n                    current_element[0] = \"\"\n                return _DELIMITED\n            else:\n                current_element[0] += c\n                return _IN_UNQUOTED\n\n        # Functions in the execution vector must be ordered identically to the\n        # indexes represented by the state constants.\n        exec_vector = [\n            in_quoted,\n            escaped,\n            quote_in_quoted,\n            in_unquoted,\n            between,\n            delimited,\n        ]\n        # Set the starting state.\n        state = _BETWEEN\n        # Process the line of text.\n        for i, c in enumerate(self.text):\n            state = exec_vector[state]()\n        # Process the end-of-line condition.\n        if len(esc_buf[0]) > 0:\n            current_element[0] += esc_buf[0]\n        if len(current_element[0]) > 0:\n            elements.append(current_element[0])\n        return elements\n\n    def well_quoted_line(self, delim, qchar):\n        # Returns a tuple of boolean, int, and boolean, indicating: 1) whether the line is\n        # well-quoted, 2) the number of elements for which the quote character is used,\n        # and 3) whether the escape character is used.\n        wq = [self._well_quoted(el, qchar) for el in self.items(delim, qchar)]\n        return (\n            all([b[0] for b in wq]),\n            sum([b[1] for b in wq]),\n            any([b[2] for b in wq]),\n        )\n\ndef diagnose_delim(linestream, possible_delimiters=None, possible_quotechars=None):\n    # Returns a tuple consisting of the delimiter, quote character, and escape\n    # character for quote characters within elements of a line.  All may be None.\n    # If the escape character is not None, it will be u\"\\\".\n    # Arguments:\n    # * linestream: An iterable file-like object with a 'next()' method that returns lines of text\n    #  as bytes or unicode.\n    # * possible_delimiters: A list of single characters that might be used to separate items on\n    #  a line.  If not specified, the default consists of tab, comma, semicolon, and vertical rule.\n    #  If a space character is included, multiple space characters will be treated as a single\n    #  delimiter--so it's best if there are no missing values on space-delimited lines, though\n    #  that is not necessarily a fatal flaw unless there is a very high fraction of missing values.\n    # * possible_quotechars: A list of single characters that might be used to quote items on\n    #  a line.  If not specified, the default consists of single and double quotes.\n    if not possible_delimiters:\n        possible_delimiters = [\"\\t\", \",\", \";\", \"|\"]\n    if not possible_quotechars:\n        possible_quotechars = ['\"', \"'\"]\n    lines = []\n    for i in range(100):\n        try:\n            ln = linestream.next()\n        except StopIteration:\n            break\n        except:\n            raise\n        while len(ln) > 0 and ln[-1] in (\"\\n\", \"\\r\"):\n            ln = ln[:-1]\n        if len(ln) > 0:\n            lines.append(CsvLine(ln))\n    if len(lines) == 0:\n        raise CsvDiagError(\"CSV diagnosis error: no lines read\")\n    for ln in lines:\n        for d in possible_delimiters:\n            ln.count_delim(d)\n    # For each delimiter, find the minimum number of delimiters found on any line, and the number of lines\n    # with that minimum number\n    delim_stats = {}\n    for d in possible_delimiters:\n        dcounts = [ln.delim_count(d) for ln in lines]\n        min_count = min(dcounts)\n        delim_stats[d] = (min_count, dcounts.count(min_count))\n    # Remove delimiters that were never found.\n    for k in delim_stats.keys():\n        if delim_stats[k][0] == 0:\n            del delim_stats[k]\n\n    def all_well_quoted(delim, qchar):\n        # Returns a tuple of boolean, int, and boolean indicating: 1) whether the line is\n        # well-quoted, 2) the total number of lines and elements for which the quote character\n        # is used, and 3) the escape character used.\n        wq = [l.well_quoted_line(delim, qchar) for l in lines]\n        return (\n            all([b[0] for b in wq]),\n            sum([b[1] for b in wq]),\n            CsvLine.escchar if any([b[2] for b in wq]) else None,\n        )\n\n    def eval_quotes(delim):\n        # Returns a tuple of the form to be returned by 'diagnose_delim()'.\n        ok_quotes = {}\n        for q in possible_quotechars:\n            allwq = all_well_quoted(delim, q)\n            if allwq[0]:\n                ok_quotes[q] = (allwq[1], allwq[2])\n        if len(ok_quotes) == 0:\n            return (delim, None, None)  # No quotes, no escapechar\n        else:\n            max_use = max([v[0] for v in ok_quotes.values()])\n            if max_use == 0:\n                return (delim, None, None)\n            # If multiple quote characters have the same usage, return (arbitrarily) the first one.\n            for q in ok_quotes.keys():\n                if ok_quotes[q][0] == max_use:\n                    return (delim, q, ok_quotes[q][1])\n\n    if len(delim_stats) == 0:\n        # None of the delimiters were found.  Some other delimiter may apply,\n        # or the input may contain a single value on each line.\n        # Identify possible quote characters.\n        return eval_quotes(None)\n    else:\n        if len(delim_stats) > 1:\n            # If one of them is a space, prefer the non-space\n            if \" \" in delim_stats.keys():\n                del delim_stats[\" \"]\n        if len(delim_stats) == 1:\n            return eval_quotes(delim_stats.keys()[0])\n        # Assign weights to the delimiters.  The weight is the square of the minimum number of delimiters\n        # on a line times the number of lines with that delimiter.\n        delim_wts = {}\n        for d in delim_stats.keys():\n            delim_wts[d] = delim_stats[d][0] ** 2 * delim_stats[d][1]\n        # Evaluate quote usage for each delimiter, from most heavily weighted to least.\n        # Return the first good pair where the quote character is used.\n        delim_order = sorted(delim_wts, key=delim_wts.get, reverse=True)\n        for d in delim_order:\n            quote_check = eval_quotes(d)\n            if quote_check[0] and quote_check[1]:\n                return quote_check\n        # There are no delimiters for which quotes are OK.\n        return (delim_order[0], None, None)\n    # Should never get here\n    raise CsvDiagError(\"CSV diagnosis error: an untested set of conditions are present\")\n```\n\n## Import CSV to a Database\n\n```py\nclass CsvFile(object):\n    \"\"\"CsvFile class automatically opens a file and creates a CSV reader, reads the first row containing column headers, and stores those headers so that they can be used to construct the INSERT statement.\"\"\"\n    def __init__(self, filename):\n        self.fn = filename\n        self.f = None\n        self.open()\n        self.rdr = csv.reader(self.f)\n        self.headers = next(self.rdr)\n    def open(self):\n        if self.f is None:\n            mode = \"rb\" if sys.version_info < (3,) else \"r\"\n            self.f = open(self.fn, mode)\n    def reader(self):\n        return self.rdr\n    def close(self):\n        self.rdr = None\n        self.f.close()\n        self.f = None\n\n\nclass Database(object):\n    \"\"\"The Database class and subclasses provide a database connection for each type of DBMS, and a method to construct an INSERT statement for a given CsvFile object, using that DBMS's parameter substitution string.  The conn_info argument is a dictionary containing the host name, user name, and password.\"\"\"\n    def __init__(self, conn_info):\n        self.paramstr = '%s'\n        self.conn = None\n    def insert_sql(self, tablename, csvfile):\n        return \"insert into %s (%s) values (%s);\" % (\n                tablename,\n                \",\".join(csvfile.headers),\n                \",\".join([self.paramstr] * len(csvfile.headers))\n                )\n\n\nclass PgDb(Database):\n    def __init__(self, conn_info):\n        self.db_type = \"p\"\n        import psycopg2\n        self.paramstr = \"%s\"\n        connstr = \"host=%(server)s dbname=%(db)s user=%(user)s password=%(pw)s\" % conn_info\n        self.conn = psycopg2.connect(connstr)\n\n    def postgres_copy(csvfile, db):\n        \"\"\"Postgres COPY command. Fastest implementation\"\"\"\n        curs = db.conn.cursor()\n        rf = open(csvfile.fn, \"rt\")\n        # Read and discard headers\n        hdrs = rf.readline()\n        copy_cmd = \"copy copy_test from stdin with (format csv)\"\n        curs.copy_expert(copy_cmd, rf)\n\n    def simple_copy(csvfile, db):\n        \"\"\"Row-by-row reading and writing\"\"\"\n        ins_sql = db.insert_sql(\"copy_test\", csvfile)\n        curs = db.conn.cursor()\n        rdr = csvfile.reader()\n        for line in rdr:\n            curs.execute(ins_sql, clean_line(line))\n        db.conn.commit()\n\n    def buffer1_copy(csvfile, db, buflines):\n        \"\"\"Buffered reading and writing\"\"\"\n        ins_sql = db.insert_sql(\"copy_test\", csvfile)\n        curs = db.conn.cursor()\n        rdr = csvfile.reader()\n        eof = False\n        while True:\n            b = []\n            for j in range(buflines):\n                try:\n                    line = next(rdr)\n                except StopIteration:\n                    eof = True\n                else:\n                    b.append(clean_line(line))\n            if len(b) > 0:\n                curs.executemany(ins_sql, b)\n            if eof:\n                break\n        db.conn.commit()\n```\n\n",
    "supporting": [
      "python_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}